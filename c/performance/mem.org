#+Title: Notes on NUMA

** 使用NUMA可能会有意外的SWAP发生
内核在缺页时申请新页有三种情形:
1. local node alloc, 从当前线程所关联的node中分配内存
2. remote node alloc, 从其他node那借用内存
3. swap local page, 当前CPU相连的物理页不够，所以可以选择淘汰一些虚页。
内核在获取物理页时如果策略选择不当，可能导致第三种情况频繁出现，尤其是当某个CPU本地的物理页紧缺时。
如果程序在启动时就分配内存，初始化许多结构，然后由不同的线程处理，这可能不是一个好的做法，因为这样主线程所在的CPU本地的内存从一开始就被分配出去了许多。
比较好的做法就是由使用内存的线程分配内存。
鉴于NUMA带来的问题，如果写程序时不是特别注意，还不如把NUMA禁用了。

** 精巧的数据结构也许不如紧凑的数据结构
   鉴于存储具有明显的层次结构，并且一般CPU的速度要快于访存或IO，所以在很多时候优化访存或IO的数量或模式(减少随机访问)是一种很有效的优化方法。
#+begin_example
Register: <1ns
L1 Cache: 2ns
L2 Cache: 20~30ns
Mem: 100ns
#+end_example
特别是指针的间接跳转，如果能用内嵌数组代替就是一个比较好的优化方向。
