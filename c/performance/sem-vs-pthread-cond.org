#+Title: sem vs pthread\_cond

用pthread写多线程程序时，线程间的同步一般用pthread\_cond加用户之间维护的状态变量实现，
而很少用操作系统提供的semahpore，当然semaphore有不可取代的地方，因为它可以实现不同进程
间的同步，但正因为如此，一般认为semaphore的代价较大，并且这种可以跨进程实现同步的semaphore
需要与一个文件描述符对应，所以受到打开的文件描述符的个数限制。几乎可以肯定这种semaphore的代价
是很大的，但是如果是不跨进程的semaphore呢？这样没有文件描述符个数的限制，并且也没有道理会比
pthread\_cond慢很多。实际情况如何呢?

下面测试了两个线程1600次操作的ops(operations/s)，模仿生产者消费者问题，一个生产者，一个消费者。
只是消去了除去线程同步之外的所有操作。
#+begin_example
进程私有的semaphore: 1000000*16777216/8764967=1914121
跨进程的semaphore: 1000000*16777216/8256771=2031934
pthread_cond: 1000000*16777216/15342334=1093524
#+end_example
第二次和第三次测试的结果分别是:2174793,2052874,1301505; 1925312,2601299,1294314
虽然波动还是较大的，但从上面测试的结果看来，使用semaphore要更好，大约快了一倍。而用semaphore时是否是进程局部的则几乎对性能没什么影响。

