#+Title: CPU scheduler

round robin scheduler，O(n) scheduler, O(1) scheduler, Rotating Staircase Deadline Scheduler, Complete Fair Scheduler.

首先，下面所有的调度器都可以用同样的方法在多核系统上扩展：为每个进程分配一个核，每个核单独用一个调度器，
进程当然可以在核之间迁移，但我们假定迁移不会和调度一样频繁，所以可以用更低效的算法。这里不讨论多核的扩展性:
1. round robin scheduler:
   最简单的调度策略当然是让每个进程轮转使用CPU，使用单个环形队列，每次选择队列头部的一个进程执行，
   并且同时把该进程移到队列的尾部。这种方法实现简单，但是功能不够，因为它没有区分优先级，
   也不公平(可能让IO bound的进程分到的CPU时间变少)。因为这些原因，交互式任务的响应也会变慢。
2. O(n) scheduler:
   为了解决轮转法的问题，可以在每次调度的时候用更复杂的算法算出一个优先级，选择优先级最高的进程执行。这种方法可以使用
   任意复杂的优先级策略，但每次选择的时间变成了O(n)。
3. O(1) scheduler:
   如果进程太多，O(n) scheduler不可接受，但是我们也不能回到round robin算法，因为进程必须要求具有优先级，并且调度器需要能优先执行IO bound的任务。
   于是便有了O(1) scheduler, 这种调度器的主要想法是规定固定数目的优先级，为每个优先级使用一个独立的队列(实际上是两个, 但不影响我们的理解),
   每个优先级都按round robin方法调度。选择一个进程现在要分两步，第一步选择一个队列非空的最高优先级, 第二步从该队列中选择
   队首元素执行。虽然进程数可以很多，但是优先级数目却是有限的。所以它的执行是O(1)。
   进程的优先级可以动态调整，所以我们可以增加IO bound的进程的优先级，降低CPU bound的进程的优先级。
4. CFS，complete fair scheduler: 
   O(1) scheduler虽然实现简单，并且能区分优先级，但是它区分IO bound的任务和CPU bound的任务的方法没有理论依据，这样写出的算法很难考虑完备。
   CFS与O(1) scheduler相比，不用各种ad hoc的方法区分IO bound和CPU bound的任务，而是对各种任务一视同仁，它的目标是让各个正在执行的任务
   均分CPU时间。CFS保证的是sleeper fairness，也就是说即使一个进程因为等待IO而睡眠，在这个睡眠期间它也应该享有和ready的进程同样的CPU时间。
   执行这个原则的结果是: 如果一个进程是IO bound的，那么它睡眠的时间就会更多，那么当它需要CPU时间的时候，就会优先满足；如果该进程随后变成了
   CPU bound的，那么等到它之前所有的睡眠时间都被偿还之后优先级自然就会降下来。
   CFS的调度原则可以用一个理想的CPU来理解，假设当前的进程数是n，那么n个进程同时在CPU上执行，每个进程都只能获得1/n的处理器能力，
   由于CPU是不可能同时均分给不同的进程使用的，所以CFS要用等价的原则，即如果当前有n个进程，那么经过一个单位时间t之后，每个进程应该获得
   t/n的处理器时间。由于CPU一次只能执行一个进程，那么在大部分时间，每个进程理应获得的处理时间都不能满足, 就像欠帐一样，CPU总是"欠"每个进程的时间。
   按照这个方式来理解，CFS每次总是选择最大的"债主"来还债，保证任意时刻都不会欠某个进程特别多的债。
   
   按上面的方式来实现CFS，关键就是维护一个帐本，记录CPU欠每个进程的处理时间，每次从帐簿中选择一项最大的执行，
   用一个平衡树或堆就可以维护这个帐簿，但是由于每次更新要更新所有的项，这是不可接受的。
   最妙的一点就是由于每次更新时，几乎所有项都是加上了1/n，所以我们只要调整一下基准值，把这1/n的量累加到全局的基准值上，
   那么每次更新就只需要调整一项就够了，这一项就是上一个时间片段占用了CPU的进程，它的应得时间要减去1, 其余的项不变，
   同时把全局的一个base加1/n。随之变化的是每次新创建一个进程的时候，该进程的应得时间不是0，而是 0-base。
   
