#+Title: Dead Lock

处理死锁的四种方法:
1. ignore: 所谓忽略是指系统不尝试自动解决，但是一旦发生死锁，也需要能在人工干预的情况下解决，比如kill进程, 最坏的情况是重启系统。
   假定死锁发生的概率足够低，并且解决死锁的代价不太大，是可以忽略死锁。
2. detect: 系统自动检测死锁，一旦检测到死锁，解决的办法也只有kill进程或abort transaction了。
   当然可以强制已经获得锁的进程或transaction释放锁，但是一般来讲强制释放已拿到的锁, 为了保证逻辑正确, 
   进程必须要结束，transaction也只能回滚。另外检测死锁也是很复杂的，实践中可以采用更简单的算法，
   只要等待资源超过了一个时间限制，就可以认为发生了死锁，这时就可以让进程或事务abort。可以重新执行回滚的事务
   但是在重试之前要随机等待一段时间，以免形成活锁。
3. prevention: 破坏形成死锁的条件:
   a. 消除对资源的互斥锁, 实践中不可能。
   b. 不允许拿到资源后再申请新的资源，要求进程原子性地把所有的资源都申请完毕。这一般也是不可能的，即使可能也是低效的。
   c. 破坏不允许抢占资源的条件，如果操作可以回滚，这还是有可能实现的。
   d. 破坏循环等待的条件，当可能出现循环等待时，资源申请就会失败。比如可以采用Dijkstra's solution(即按序申请资源)
4. Avoidance: Dijkstra's solution或银行家算法都属于这一类，但是实践中很难应用。
   比较可行的方案是Wait/Die和Wound/Wait, 每个进程都有运行时间，或者称为年龄，假设没有两个进程的年龄相同(很容易保证), 
   那么这两种方案的原则是当两个进程都申请都一个资源时，优先把资源给年老的进程。
   Wait/Die方案是: 如果年老的进程申请的资源被年青的进程占有，年老的进程等待；如果年青的进程申请的资源被年老的进程占有，年青的进程退出。
   Wound/Wait方案是: 如果年老的进程申请的资源被年青的进程占有，年青的进程退出；如果年青的进程申请的资源被年老的进程占有，年青的进程等待。
   显然按这种方案，系统中最老的进程一定不会成为死锁中的一环，当最老的进程执行完毕后，新的最老的进程也不会成为死锁中的一环。最终避免死锁。
   这种方案里的年龄本质上只是一个优先级，换成别的指标也是可行的。
综合起来，Wait/Die和Wound/Wait方案和超时检测死锁是比较可行的方案。
   
   
   
