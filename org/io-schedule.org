#+Title: io-schedule

io设备和CPU一样属于共享资源，但是操作系统的抽象使得每个进程独享所有的资源，所以便有了各种各样的调度策略。
io调度有三种方法:
1. NOOP scheduler: 这是一种最简单的IO调度器，它使用单一的队列，新的io请求直接插入到队列的末尾，但是它会把可以合并的请求合并起来。
   虽然简单，但不是没用，使用ssd时，NOOP scheduler还是很适合的，因为ssd不需要寻址，或者是带raid卡的磁盘，raid控制器可能有重新对
   io请求排序的功能，这种情况下也可以直接使用NOOP scheduler。
2. Deadline scheduler: 它的策略是给每个请求分配一个deadline，这个deadline指开始服务该请求的时间。快到deadline的请求具有最高优先级，
   但是如果所有的请求都没到deadline，那么就按照sector地址排序后的结果服务。deadline scheduler维护两个队列，一个队列按deadline排序，
   一个队列按sector地址排序，如果deadline队列中有请求要到期了，那么就选择它服务，如果没有，就从按地址排序的队列中取出队首请求服务。
   不管是那种情况，一旦选择了一个请求去服务，那么按地址排序后在它后面的一批请求也会被服务。实际上为了公平，deadline scheduler内部会
   使用多个队列，轮流选择队列去服务。
3. Anticipatory scheduling：这种策略的目的是为了避免"Deceptive idleness", 假想一个进程要发起一批连续
   地址的IO请求，比如读一个大文件，然后处理。由于程序的逻辑只能实现为读一块数据到缓冲区，处理完之后再读另一块。在连续两次读之间
   是有时间间隔的，如果IO请求处理地快，前一次请求处理完之后，从操作系统的角度看，这个进程暂时就没有IO请求了，这种场景就叫"Deceptive idleness".
   如果IO scheduler在这种情况下转去服务别的进程的请求，那么就可能导致磁头来回跳转，Anticipatory scheduling的策略是服务完一次读请求
   之后等待一个很短的时间(几毫秒)，再去决定服务那个请求。这种策略可能导致磁盘利用率升高，也可能会下降。它在提高延迟的的同时提高了
   IO请求的locality，适合比较慢的磁盘。
4. Completely Fair Queuing：这种调度的策略是给每个进程按优先级分配IO服务时间。每个进程一个IO请求的队列，
   同步请求被放置在这个队列(多线程发出的多个请求), 异步请求按优先级放在全局的队列中，全局每个优先级一个队列。
   CFQ会对IO请求按地址排序，与CFQ相比最大的优点就是公平。
