#+Title: loser tree

当做多路归并时，如果路数比较多，可以使用堆，也可以使用胜者树或败者树，一般认为败者树更优。这是为什么呢？
但是如果我们要排序却一般选择堆排序,而很少有人用胜者树或败者树排序呢?

败者树可以看作是胜者树的改进，所以先不考虑它。先看看已经建好的堆，胜者树各是什么样子的。
** 堆:
假定是小顶堆，堆可以看作是完全二叉树，任意一个节点的都小于其左右孩子(如果左右孩子存在的话)，从而任意一棵子树的根都是这棵树中最小的元素。
特别地，整棵树的根节点是所有元素中最小的，这个根也叫堆的堆顶。

下面的这棵树表示了7个元素的堆。
#+begin_example
      1
  5       4
6   9   8   7
#+end_example

** 胜者树
假定小者胜， 胜者树也对应着一棵完全二叉树，但是它区分内部节点和外部节点(也就是最下面一层的页节点)，用比赛的术语，每一个外部节点可以看作是一个player，
每一个内部节点可以看作是一次比赛，胜者树记录了这次比赛的胜者，对应地，败者树记录的是败者。

下面的这棵树表示了4个元素的堆。
#+begin_example
      6
  6       7
6   9   8   7
#+end_example

** 堆的优点: 省空间
从上面可以清楚的看到，堆相对于胜者树的优势：堆更省空间，每个节点在堆中只出现一次，占用空间为n, 但是胜者树和败者树却需要占用2n-1的空间. 
对于一般的排序而言，额外的空间是不小的开销，所以很少使用胜者树或败者树。但是对多路归并而言，归并的路数一般较少，所以需要更关心调整的代价。

** 胜者树的优点: 调整快
对堆来说，不管是从上向下调整，还是从下向上调整，每次都要比较三个节点: 一个父节点和两个孩子。 选择最小的成为父节点。
但是对胜者树而言，都是从下向上调整，每次调整只需要和兄弟节点比较，选择最小的成为父节点即可。

5. 败者树对胜者树的改进: 修改更少
败者树对胜者树的修改在于: 内部节点记录比赛的败者
假定小者胜. 除了内部节点和外部节点，还需要单独记录整个树的胜者
#+begin_example
      6  <-- 整个树的胜者
      7
  9       8
6   9   8   7
#+end_example
败者树在调整的时候，比较次数和胜者树一样，每一层比较一次(和父节点比)，但是对整棵树的修改更少。
胜者树调整时每一次比较都要修改一次胜者，因为胜者一定会变化，但是败者树调整时不一定每次都要修改，因为败者可能不变。
