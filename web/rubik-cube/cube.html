<html>
  <head>
    <title>Rubik Cube</title>
    <!-- <script type="application/javascript;version=1.8" src="common.js"></script> -->
    <script type="application/javascript;version=1.8">
      //////////////////////////////////////// Common ////////////////////////////////////////
      function irange(n){ for(let i = 0; i < n; i++)yield i; }
      function range(n) [i for each(i in irange(n))]
      function list(iters) [x for each(x in iters)]
      function min(seq, comp) seq.length > 0 && seq.sort(comp)[0]
      function sum(seq) seq.reduce(function(v1, v2) v1+v2)
      function repr(obj) JSON.stringify(obj)
      function bind(obj, attrs) {for (let [k,v] in Iterator(attrs))obj[k]=v; return obj;}
      String.prototype.format = function(dict) this.replace(/{(\w+)}/g, function(m,k) dict[k])
      
      function log() window.console &&  console.log.apply(null, arguments)
      function $(id) document.getElementById(id)
      function isHotKey(e, key) String.fromCharCode(e.charCode).toUpperCase() == key.toUpperCase()
      function bindKey(w, key, handler) w.addEventListener('keypress', function(e) isHotKey(e, key) && handler(e), false);
      
      //////////////////////////////////////// Transform ////////////////////////////////////////
      function transpose(A) [[row[i] for each(row in A)]  for (i in A[0])]
      function innerProduct(A, B) sum([A[i]*B[i] for(i in A)])
      function transform(v, B) [innerProduct(v, col) for each(col in transpose(B))]
      function matMul(Am, Bm) [transform(row, Bm) for each(row in Am)]
      function xyzk2xy([x, y, z, k]) [x/k, y/k]

      var [sin, cos] = [Math.sin, Math.cos];
      function translate(dx, dy, dz) [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [dx, dy, dz, 1]]
      function scale(sx, sy, sz) [[sx, 0, 0, 0], [0, sy, 0, 0], [0, 0, sz, 0], [0, 0, 0, 1]]
      function rotateX(a) [[1, 0, 0, 0], [0, cos(a), sin(a), 0], [0, -sin(a), cos(a), 0], [0, 0, 0, 1]]
      function rotateY(b) [[cos(b), 0, -sin(b), 0], [0, 1, 0, 0], [sin(b), 0, cos(b), 0], [0, 0, 0, 1]]
      function rotateZ(c) [[cos(c), sin(c), 0, 0], [-sin(c), cos(c), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]
      function rotate(a, b, c) [rotateX(a), rotateY(b), rotateZ(c)].reduce(matMul)
      function place(L, [x0, y0, z0], [a, b, c]) [scale(L, L, L), rotate(a, b, c), translate(x0, y0, z0)].reduce(matMul)
      
      //////////////////////////////////////// Polygon ////////////////////////////////////////
      function polygon(ctx, _ps){
          var ps = _ps.map(xyzk2xy);
          ctx.save();
          bind(ctx, {strokeStyle:'black', lineWidth: '3', lineCap: 'round', lineJoin: 'round'});
          ctx.fillStyle = _ps.color;
          ctx.beginPath();
          var [x0, y0] = ps[0];
          ctx.moveTo(x0, y0); 
          for each([x, y] in ps.slice(1))ctx.lineTo(x, y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.restore();
      }

      function polygons(ctx, planes){
          planes.map(function(p) polygon(ctx, p));
      }

      //////////////////////////////////////// Cube ////////////////////////////////////////
      var cube0 = [[((i&1)*2 - 1)/2, ((i&2) - 1)/2, ((i&4)/2 - 1)/2, 1] for each(i in irange(8))];
      function cubePlanes(ps){
          var planes = [[0,2,6,4], [1,3,7,5], [0, 1, 5, 4], [2,3,7,6], [0,1,3,2], [4,5,7,6]];
          return [plane.map(function(x) ps[x]) for each(plane in planes)];
      }
      
      //////////////////////////////////////// RubikRenderer Utilities ////////////////////////////////////////
      function $3(x) [x%3, Math.floor((x/3) % 3), Math.floor(x/9)]
      
      function rubik2cubes(L, [x0, y0, z0], abc, dir, angles){
          function id2xyz(id) $3(id).map(function(x) x-1)
          function ref(id) 13 + ($3(id)[dir] - 1) * [1,3,9][dir]
          var pos_ref = [[id2xyz(i), id2xyz(ref(i))] for each(i in range(27))];
          var cubes = [matMul(cube0, translate(x, y, z)).concat([[rx,ry,rz,1]]) for each([[x, y, z], [rx,ry,rz]] in pos_ref)];
          function rotate(dir, angles, i) [rotateX, rotateY, rotateZ][dir](angles[$3(i)[dir]]);
          cubes = [matMul(ps, rotate(dir, angles, i)) for each([i, ps] in Iterator(cubes))];
          return [matMul(cube, place(L, [x0, y0, z0], abc)) for each(cube in cubes)];
      }
      
      function rubikGetColorId(permute, cubeId, planeId){
          return $3(permute[cubeId])[Math.floor(planeId/2)] == (planeId%2 * 2)? planeId: 6;
      }
      
      function rubikSortPlanes(planes){
          function maxZ(plane) min(plane.map(function([x,y,z,k])z/k), function(z1, z2) z2-z1)
          function refZ(plane) plane.ref[2]/plane.ref[3]
          return planes.sort(function(p1, p2) (refZ(p1) == refZ(p2))? (maxZ(p1) - maxZ(p2)): (refZ(p1) - refZ(p2)));
      }
      
      function rubikDraw(ctx, L, xyz0, abc, dir, angles, permutation, cm){
          var cubes = rubik2cubes(L, xyz0, abc, dir, angles);
          function planeNew(p, ref, cId, pId) bind(p, {ref:ref, color:cm[rubikGetColorId(permutation, cId, pId)]})
          var planes = [[planeNew(p, cube[8], i, j) for each([j, p] in Iterator(cubePlanes(cube)))] for each([i, cube] in Iterator(cubes))];
          polygons(ctx, rubikSortPlanes(Array.concat.apply([], planes)));
      }
      
      function makeRubikRenderer(ctx, L, xyz0, cm){
          cm = cm || ['white', 'red', 'blue', 'orange', 'green', 'yellow', 'grey'];
          return function render(permute, abc, dir, angles){
              ctx.clearRect(0, 0, 600, 600); 
              rubikDraw(ctx, L, xyz0, abc, dir, angles, permute, cm);
          }
      }
      
      //////////////////////////////////////// Rubik ////////////////////////////////////////
      function Rubik(render, permute, abc, dir, angles){
          bind(this, {render: render, permute: permute || range(27), abc: abc || [0,0,0] , dir: dir || 0,
               angles: angles || [0.4, 0, 0.3]});
      }
      Rubik.prototype.draw = function() this.render(this.permute, this.abc, this.dir, this.angles)
      Rubik.prototype.gRotate = function(dir, delta) this.abc[dir] += delta
      Rubik.prototype.setDir = function(dir) [this.dir, this.angles] = [dir, [0, 0, 0]]
      Rubik.prototype.rotate = function(pos, delta) this.angles[pos] += delta
      
      //////////////////////////////////////// UI ////////////////////////////////////////
      function keyHandler(rubik, key){
          var handlers = {
              W:function() rubik.gRotate(0, 0.1), S:function() rubik.gRotate(0, -0.1),
              A:function() rubik.gRotate(2, 0.1), D:function() rubik.gRotate(2, -0.1),
              Q:function() rubik.gRotate(1, -0.1), E:function() rubik.gRotate(1, 0.1),
              X:function() rubik.setDir(0), Y:function() rubik.setDir(1), Z:function() rubik.setDir(2),
              H:function() rubik.rotate(0, 0.1), L:function() rubik.rotate(0, -0.1),
              J:function() rubik.rotate(2, 0.1), K:function() rubik.rotate(2, -0.1), };
         (handlers[key] || function() null)();
         rubik.draw();
      }
      
      function initApp(canvas) {
          var ctx = canvas.getContext('2d');
          var rubik = new Rubik(makeRubikRenderer(ctx, 100, [300,300,0]));
          rubik.draw();
          top.addEventListener('keypress', function(e) keyHandler(rubik, String.fromCharCode(e.charCode).toUpperCase()), false);
      }
    </script>
  </head>
  <body onload="initApp($('canvas'))">
    <canvas id="canvas" width="600" height="600">Your browser does not support HTML5 Canvas.</canvas>
  </body>
</html>
