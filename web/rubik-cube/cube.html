<html>
  <head>
    <title>Rubik Cube</title>
    <!-- <script type="application/javascript;version=1.8" src="common.js"></script> -->
    <script type="application/javascript;version=1.8">
      //////////////////////////////////////// Common ////////////////////////////////////////
      function irange(n){ for(let i = 0; i < n; i++)yield i; }
      function range(n) [i for each(i in irange(n))]
      function list(iters) [x for each(x in iters)]
      function min(seq, comp) seq.length > 0 && seq.sort(comp)[0]
      function sum(seq) seq.reduce(function(v1, v2) v1+v2)
      function repr(obj) JSON.stringify(obj)
      function bind(obj, attrs) {for (let [k,v] in Iterator(attrs))obj[k]=v; return obj;}
      String.prototype.format = function(dict) this.replace(/{(\w+)}/g, function(m,k) dict[k])
      
      function log() window.console &&  console.log.apply(null, arguments)
      function $(id) document.getElementById(id)
      function isHotKey(e, key) String.fromCharCode(e.charCode).toUpperCase() == key.toUpperCase()
      function bindKey(w, key, handler) w.addEventListener('keypress', function(e) isHotKey(e, key) && handler(e), false);
      
      //////////////////////////////////////// Transform ////////////////////////////////////////
      function transpose(A) [[row[i] for each(row in A)]  for (i in A[0])]
      function innerProduct(A, B) sum([A[i]*B[i] for(i in A)])
      function transform(v, B) [innerProduct(v, col) for each(col in transpose(B))]
      function matMul(Am, Bm) [transform(row, Bm) for each(row in Am)]
      function xyzk2xy([x, y, z, k]) [x/k, y/k]

      var [sin, cos] = [Math.sin, Math.cos];
      function translate(dx, dy, dz) [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [dx, dy, dz, 1]]
      function scale(sx, sy, sz) [[sx, 0, 0, 0], [0, sy, 0, 0], [0, 0, sz, 0], [0, 0, 0, 1]]
      function rotateX(a) [[1, 0, 0, 0], [0, cos(a), sin(a), 0], [0, -sin(a), cos(a), 0], [0, 0, 0, 1]]
      function rotateY(b) [[cos(b), 0, -sin(b), 0], [0, 1, 0, 0], [sin(b), 0, cos(b), 0], [0, 0, 0, 1]]
      function rotateZ(c) [[cos(c), sin(c), 0, 0], [-sin(c), cos(c), 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]
      function rotate(a, b, c) [rotateX(a), rotateY(b), rotateZ(c)].reduce(matMul)
      function place(L, [x0, y0, z0], [a, b, c]) [scale(L, L, L), rotate(a, b, c), translate(x0, y0, z0)].reduce(matMul)
      
      //////////////////////////////////////// Polygon ////////////////////////////////////////
      function polygon(ctx, _ps){
          var ps = _ps.map(xyzk2xy);
          ctx.save();
          bind(ctx, {strokeStyle:'black', lineWidth: '3', lineCap: 'round', lineJoin: 'round'});
          ctx.fillStyle = _ps.color;
          ctx.beginPath();
          var [x0, y0] = ps[0];
          ctx.moveTo(x0, y0); 
          for each([x, y] in ps.slice(1))ctx.lineTo(x, y);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.restore();
      }

      function polygons(ctx, planes){
          planes.map(function(p) polygon(ctx, p));
      }

      //////////////////////////////////////// Cube ////////////////////////////////////////
      var cube0 = [[((i&1)*2 - 1)/2, ((i&2) - 1)/2, ((i&4)/2 - 1)/2, 1] for each(i in irange(8))];
      function cubePlanes(ps){
          var planes = [[0,2,6,4], [1,3,7,5], [0, 1, 5, 4], [2,3,7,6], [0,1,3,2], [4,5,7,6]];
          return [plane.map(function(x) ps[x]) for each(plane in planes)];
      }
      
      //////////////////////////////////////// Rubik ////////////////////////////////////////
      var rubik = {permute: range(27), abc: [0, 0, 0], dir:0, angles:[0.4, 0, 0.3]};
      
      function $3(x) [x%3, Math.floor((x/3) % 3), Math.floor(x/9)]

      function rubikNew(L, [x0, y0, z0], rubik){
          function id2xyz(id) $3(id).map(function(x) x-1)
          function ref(id) 13 + ($3(id)[rubik.dir] - 1) * [1,3,9][rubik.dir]
          var pos_ref = [[id2xyz(i), id2xyz(ref(i))] for each(i in range(27))];
          var cubes = [matMul(cube0, translate(x, y, z)).concat([[rx,ry,rz,1]]) for each([[x, y, z], [rx,ry,rz]] in pos_ref)];
          function rotate(rubik, i) [rotateX, rotateY, rotateZ][rubik.dir](rubik.angles[$3(i)[rubik.dir]]);
          cubes = [matMul(ps, rotate(rubik, i)) for each([i, ps] in Iterator(cubes))];
          return [matMul(cube, place(L, [x0, y0, z0], rubik.abc)) for each(cube in cubes)];
      }
      
      function rubikGetColor(rubik, cubeId, planeId){
          var colors = ['white', 'red', 'blue', 'orange', 'green', 'yellow', 'grey'];
          function getColorId(cubeId, planeId) $3(cubeId)[Math.floor(planeId/2)] == (planeId%2 * 2)? planeId: 6
          return colors[getColorId(rubik.permute[cubeId], planeId)];
      }
      
      function rubikSort(rubik, planes){
          function maxZ(plane) min(plane.map(function([x,y,z,k])z/k), function(z1, z2) z2-z1)
          function refZ(plane) plane.ref[2]/plane.ref[3]
          return planes.sort(function(p1, p2) (refZ(p1) == refZ(p2))? (maxZ(p1) - maxZ(p2)): (refZ(p1) - refZ(p2)));
      }
      
      function rubikRedraw(rubik, ctx){
          var [L, x0, y0, z0] = [100, 300, 300, 0];
          ctx.clearRect(0, 0, 600, 600);
          var planes = [[bind(p, {ref:cube[8], color:rubikGetColor(rubik, i, j)}) for each([j, p] in Iterator(cubePlanes(cube)))] for each([i, cube] in Iterator(rubikNew(L, [x0, y0, z0], rubik)))];
          polygons(ctx, rubikSort(rubik, Array.concat.apply([], planes)));
      }

      function rubikGRotate(rubik, dir, delta) rubik.abc[dir] += delta
      function rubikSetDir(rubik, dir) [rubik.dir, rubik.angles] = [dir, [0, 0, 0]]
      function rubikRotate(rubik, pos, delta) rubik.angles[pos] += delta
      
      function rubikKeyHandler(rubik, ctx, key){
          function mkRotater(i, d) function() rubik.abc[i] += d;
          log(key);
          var handlers = {W:mkRotater(0, 0.1), S:mkRotater(0, -0.1),
              A:mkRotater(2, 0.1), D:mkRotater(2, -0.1),
              Q:mkRotater(1, -0.1), E:mkRotater(1, 0.1),
              X:function() rubikSetDir(rubik,0), Y:function() rubikSetDir(rubik, 1), Z:function() rubikSetDir(rubik, 2),
              H:function() rubikRotate(rubik, 0, 0.1), L:function() rubikRotate(rubik, 0, -0.1),
              J:function() rubikRotate(rubik, 2, 0.1), K:function() rubikRotate(rubik, 2, -0.1), };
         (handlers[key] || function() null)();
         rubikRedraw(rubik, ctx);
      }
      //////////////////////////////////////// Init ////////////////////////////////////////
      function initApp(canvas) {
          var ctx = canvas.getContext('2d');
          rubikRedraw(rubik, ctx);
          top.addEventListener('keypress', function(e) rubikKeyHandler(rubik, ctx, String.fromCharCode(e.charCode).toUpperCase()), false);
      }
    </script>
  </head>
  <body onload="initApp($('canvas'))">
    <canvas id="canvas" width="600" height="600">Your browser does not support HTML5 Canvas.</canvas>
  </body>
</html>
